# multi-user-blog

A multi-user blog app built with Node.js and Javascript that supports multiple users, RESTful API user authentication and real-time features handled by WebSockets.
This project uses a modular and environment-based configuration to run a Node.js server with MongoDB as the database and SMTP for email functionality.

## Server Entry Point

The main entry point of the application is the `server.js file`. It is responsible for loading environment variables, initializing the Express application and creating the HTTP server. Then it connects to MongoDB (either local or Atlas), sets up authentication routes, and initializes the WebSocket server with Socket.IO for real-time features. Finally, it starts the HTTP server listening on the configured host and port, handling errors if the startup fails.

## Getting Started

### Prerequisites

- Node.js v18+
- MongoDB (local or Atlas)
- A valid SMTP provider (e.g., Gmail) for sending emails

## Installation

git clone https://github.com/your-username/multi-user-blog.git
cd multi-user-blog
npm install

## Running the Application

_Development mode_: This will launch the server with live reloading using `nodemon`:

```bash
npm run dev
```

_Production mode_: Use this command to start the application with NODE_ENV=production

```bash
npm start
```

_Run Tests_: Run all test suites using Mocha:

```bash
npm test
```

The server will be available at http://localhost:8026

## Environment Variables and Configuration

The app loads environment variables based on the current `NODE_ENV` ( `development`, `test`, or `production`) from corresponding `.env` files (`.env.development`, `.env.production`).

To run the app correctly, you need to set up the following variables:

- _PORT_: the port number where the Node.js server will listen (8026).

- _HOST_: the server hostname, usually localhost for local development

- _MONGODB_URI_: the connection string for your MongoDB database, either local or hosted (like Atlas)

- _MONGO_DB_NAME_: the name of the MongoDB database to use

- _MAIL_USER and MAIL_PASS_: credentials for the SMTP service used by Nodemailer to send emails (for example, a Gmail account).

- _JWT_PUBLIC_KEY and JWT_PRIVATE_KEY_: public and private keys used to sign and verify JWT tokens for user authentication

These variables should be defined in an environment-specific `.env file` and are loaded automatically when the server starts.

## Database Connection

The database connection is handled in `/src/gateway/db.js` using Mongoose.

When running tests (NODE_ENV === 'test'), it connects to an in-memory MongoDB instance using `MongoMemoryServer`.

In other environments, it connects to the configured MongoDB instance (Atlas) using the connection string from the configuration.

This abstraction ensures a fast, isolated database environment for testing.

## Route Setup

All REST API routes are defined in the `authRoutes.js file`. These routes cover user registration, login, account activation, password reset, profile updates and fetching blog posts. Each route includes validation middleware to ensure the incoming requests meet expected formats and data requirements.
Additionally, protected routes use authentication middleware to secure user-specific operations.

## Error Handling

The application uses a centralized error-handling middleware to catch validation errors generated by Joi. When such errors occur, the middleware responds with a clear `400 status code` and an informative error message. This helps clients understand what went wrong with their requests and improves API reliability and user experience.

## User Registration

The endpoint `POST /user/register` allows a new user to register with their username, email and password.

### Validation

The request body is validated using express-joi-validation.
Required fields:

- email: must be a valid email address
- password: must be between 8 and 60 characters
- username: must be alphanumeric, 3–30 characters and unique

If the username is already in use, the server will return:

```js
{
  code: "Register_Failed",
  message: "Unable to complete registration. Please try again"
}
```

### Response (on success):

```js
{
  message: "Registration successful! Please check your email to confirm your account",
  email: "user@example.com"
}
```

## Flow

- _Route_:

Incoming requests are validated using express-joi-validation. This ensures that the request body includes a valid email, password, and username.

- _Controller_:

Once the request passes validation, the controller receives the data and forwards it to the `UserService`. It also handles known errors, such as when a username is already taken, and returns appropriate HTTP responses to the client.

- _Service Layer_:

The service layer contains the business logic:

- It first checks whether the chosen username is already in use

- The password is then securely hashed using SHA-256 with a cryptographically strong salt

- A new user is registered in the database

- A unique registration token is generated and saved

- Finally, an activation email is sent to the user using the configured EmailGateway.

- _Repository Layer_

This layer is responsible for interacting with the database:

It inserts a new user or updates an existing one with the same email if their status is not ACTIVE, ensuring that users with inactive accounts can be re-registered.

### Error Handling

- _500 Internal Server Error_ if registration fails for any internal reason

- _400 Bad Request_ if input validation fails

## Crypto Utils

Password hashing and token generation are handled using a custom crypto utility that securely salts and hashes passwords (SHA-256) and signs JWTs with RSA encryption.

## Auth Middleware

Protected routes use an authentication middleware that verifies JWT access tokens from the Authorization header and extracts the user ID from the token payload.

## User Activation

The `GET /user/activate/:token endpoint` activates a user account using the token previously sent by email during registration.

### Validation

Required fields:

- URL param: token must be a 10-character string.

- Headers must include:
  `'Content-Type': 'application/json'`

  ```js
  {
  id: "645cbbf91f6a5c7d34e7f321",
  email: "user@example.com",
  status: "ACTIVE"
  }
  ```

## Flow

- _Route_:

The route validates the incoming request using express-joi-validation.

- _Controller_:

The controller extracts the token from the request parameters and delegates the activation process to the `UserService`. It handles any thrown errors by returning the appropriate status code and message.

- _Service Layer_:

The service layer contains the business logic:

- Retrieves token from the tokenRepository

- Throws a NotFoundException if the token doesn't exist

- Calls the UserRepository.activate() method to activate the user by updating their status to ACTIVE

- Returns the activated user object

-_Repository Layer_:

The repository handles direct interaction with the database:

- Looks for a user with the provided ID and status PENDING or ACTIVE

- If found, updates their status to ACTIVE

- If no matching user is found, throws a NotFoundException

## Activation Email

The email is sent using a pluggable gateway (BasicEmailGateway by default):

```js
await this.emailGateway.sendRegistrationMail(user.email, registrationToken);
```

The email content should be as follows:

```js
Subject: Registration Confirmation

Click the link to activate your account:
http://localhost:8026/user/activate/W9v1PX7bKD

```

### Error Handling:

- _Returns 404 Not Found_ if the token is invalid or not found

- _Returns 400_ on validation error (token is not 10 characters)

- _Returns 500_ on Internal server or database error

## Username Availability Check

The endpoint `GET /user/check-username/:username` is available to check if a username is already taken. This helps frontends give instant feedback during user registration.

## Validation

Required fields:

- username: must be alphanumeric and between 3–30 characters

If validation fails (invalid characters), a 400 Bad Request is returned.

## Response

```js
{
  "available": true
}
```

If the username is already used:

```js
{
  "available": false
}
```

## Flow

- _Route_:

Validates the `username` URL parameter using express-joi-validation.

- _Controller_:

  - Extracts the username from the request parameters

  - Calls the getByUsername method from the `UserService`, passing the username received from the request to check whether it already exists in the system

  - If the user is found, returns { available: false }; otherwise, { available: true }

  - Handles internal errors and returns a status code with an error message

- _Service Layer_:

Contains the business logic for retrieving a user by username. Calls the repository method and returns the result to the controller layer.

- _Repository Layer_:

Interacts directly with the database:

- Performs a search within the userSchema to find a user document that matches the provided username

- Returns the user as a domain model instance or null if not found

- On query failure, throws a MongoInternalException

## Error Handling

- _400 Bad Request_: if the username does not meet validation rules

- _500 Internal Server Error_: if an unexpected error occurs during the lookup

## User Login

The endpoint _POST /user/login_ allows an existing user to authenticate using their credentials (email and password). On successful authentication, it returns an access token and a refresh token.

### Validation

Required fields:

- email: Must be a valid email address.

- password: Required string field.

- Headers must include:
  `'Content-Type': 'application/json'`

  ```js
  {
  email: "user@example.com",
  password: "your_password"
  }
  ```

## Flow

- _Route_:

Validates the request body using express-joi-validation. Ensures the presence and format of the following fields:

- email:
- password:

- _Controller_:

  - Extracts email and password from the request body

  - Calls UserService.login with the provided credentials

  - Handles errors by returning appropriate HTTP status codes and messages

  - On success, normalizes the user data before sending the response.

- _Service Layer_:

  - Retrieves the user by email from the repository

  - Checks if the user exists and is in ACTIVE status; otherwise throws UnauthorizedException

  - Verifies the provided password using `cryptoUtils.comparePassword`

  - If password is valid, generates JWT access and refresh tokens

  - Attaches tokens to the user object and returns it

- _Repository Layer_

  - Searches the database for a user record that matches the provided email address

  - Throws a MongoInternalException if any database error occurs

  - Returns the user object or null if not found

### Response

```js
{
  id: "609d1dfb56b2fc0021c5c4d3",
  email: "user@example.com",
  accessToken: "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...",
  refreshToken: "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

### Error Handling

- _Returns 401 Unauthorized_ if the user does not exist, is inactive, or the password is incorrect

- _Returns 400 Bad Request_ on validation error

## Forgot Password

The endpoint _POST /user/forgot-password_ initiates a password reset process by generating a secure token and sending it to the user’s email address.

### Validation

Required fields:

- email: Must be a valid email address.

- Headers must include:
  `'Content-Type': 'application/json'`

### Request Body

```js
{
"email": "user@example.com"
}
```

### Response

```js
{
  "message": "Check your email. A reset link has been sent."
}
```

## Flow

This endpoint allows users to request a password reset link via email.

- _Route_:

Accepts a POST request to /user/forgot-password and requires a JSON body with a valid email address.

- _Controller_:

  - Extracts the email from the request body

  - Passes the email to the service layer

  - Returns a success message if the process completes

  - Handles errors and returns the appropriate status code and message

- _Service Layer_:

  - Looks up the user by email

  - Checks if the user exists and is active

  - Generates a secure reset token

  - Stores the token in the reset token repository

  - Sends a reset password email via the configured email gateway

- _Repository Layer_:

Queries the database for a user by email and throws an error if the query fails

## Forgot Password Email

The reset password email is sent using a pluggable email gateway (BasicEmailGateway by default):

```
await this.emailGateway.sendResetPassword(user.email, resetToken);
```

The email content should be as follows:

```js
Subject: Reset Your Password

Click the link to reset your password:
http://localhost:8026/reset-password/W9v1PX7bKD
```

### Error Handling:

- _Returns 401 Unauthorized_ if the user does not exist or is inactive

- _Returns 400 Bad Request_ on validation error (email is required)

- _Returns 500_ on Internal server or database error

## Validate Reset Token

The endpoint `POST /user/validate-reset-token` is used to validate whether a password reset token is still valid and exists in the system. This can be useful before allowing the user to access the reset password form.

### Validation

Required fields:

- token: A required string of exactly 10 characters

- Headers must include:

`'Content-Type': 'application/json'`

### Request Body

```js
{
  "token": "10-character-token"
}
```

### Response

_If token is valid:_

```js

Status: 200 OK
{
  "valid": true,
  "message": "Valid token"
}
```

_If token is invalid or not found:_

```js

Status: 404 Not Found
{
  "valid": false,
  "message": "Reset token not found"
}
```

## Flow

- _Route_:

The client sends a POST request to /user/validate-reset-token with a JSON body containing the reset token.

- _Controller_:

The controller extracts the token from the request body and passes it to the service layer through isTokenValid(token). If the token exists in the system, it returns a 200 OK response with a message confirming its validity. Otherwise, it responds with a 404 status and an error message indicating that the token was not found

- *Service Layer":

The service handles the logic for verifying the token’s existence. It queries the reset token repository using the provided token. If a token is found, the service returns true, indicating it is valid; otherwise, it returns false.

- *Repository Layer":

The repository is responsible for communicating directly with the database to verify the existence of a reset token. It performs a query to search for a document whose resetPasswordToken field matches the provided token value. If a matching record is found, it returns the token data; otherwise, it returns null, indicating that the token is either invalid or has expired.

### Error Handling:

- Returns _400 Bad Request_ if the request fails validation (token is missing or not a string of exactly 10 characters)

- Returns _404 Not Found_ if the token does not exist in the database

- Returns _500 Internal Server Error_ for unexpected server/database failures

## Reset Password

The endpoint _POST /user/reset-password_ allows a user to reset their password using a previously generated reset token.

### Validation

Required fields:

- token: Required a 10-character string.

- password: Required string field.

- Headers must include:
  `'Content-Type': 'application/json'`

### Request Body

```js
{
  "token": "10-character-token",
  "password": "newPassword123"
}
```

### Response

```js
Status: 200 OK
{
  "message": "Password successfully reset."
}
```

## Flow

- _Route_:

The client sends a POST request to /user/reset-password with a JSON body containing the reset token and the new password.

- _Controller_:

The controller extracts the token and new password from the request body and calls the service layer to process the reset. It returns a success message if the reset succeeds or an error status/message if it fails.

- _Service Layer_:

The service first looks up the reset token in the database to verify its existence and validity. Then, it retrieves the user associated with the token and confirms the user’s status is ACTIVE. Next, it securely hashes the new password, generating a new salt. The service updates the user’s password and salt in the database, deletes the reset token to prevent reuse, and sends a confirmation email to the user.

- _Repository Layer_:

`ResetTokenRepository`: manages access to reset token data, including saving, retrieving, and deleting tokens

`UserRepository`: handles access to and updates of user data, including the password and salt.

## Confirmation Reset Password Email

After the password reset is successful, the user receives a confirmation email:

```js
Subject: Password Reset Successful

Your password has been successfully changed.
If you did not request this change, please contact support immediately.
```

### Error Handling:

- _Returns 401 Unauthorized_ if the user does not exist or is inactive

- _Returns 400 Bad Request_ on validation error (password is required)

- _Returns 500_ on Internal server or database error

## User Profile Update

The endpoint _PATCH /user/profile_ allows an authenticated user to update their profile information such as username and/or avatar.

## Authentication

This route is protected and requires a valid JWT access token in the Authorization header. The authMiddleware verifies the token and extracts the user’s ID (userId) from its payload to authorize the operation.

### Validation

Required fields:

- username: optional trimmed alphanumeric string, between 3 and 30 characters

- avatar: optional string, maximum 100 characters

- Headers must include:
  `'Content-Type': 'application/json'`

### Request

```js
Headers:
{
  "Authorization": "Bearer <access_token>",
  "Content-Type": "application/json"
}

Body:
{
  "username": "newusername",
  "avatar": "#avatar"
}
```

## Flow

- _Route_:

Validation and authorization are handled before reaching the controller.

- _Controller_:

  - Extracts userId from req.userId

  - Extracts username and avatar from req.body

  - Delegates to the Service Layer

  - Returns the updated user data and success message

- _Service Layer_:

Calls the repository to update the user by ID. Throws a NotFoundException if the user does not exist.

- _Repository Layer_:

User data is updated directly in the database. The system looks up the user by their ID and applies any provided changes, like a new username or avatar.

If something goes wrong during the database operation, a custom internal error is thrown. And if the user can’t be found, a specific not-found error is raised.

### Response

```js
Status: 200 OK
{
  "message": "Profile updated successfully",
  "id": "645cbbf91f6a5c7d34e7f321",
  "email": "user@example.com",
  "username": "newusername",
  "avatar": "#avatar"
}
```

### Error Handling:

- _Returns 401 Unauthorized_ if the JWT is missing or invalid

- _Returns 400 Bad Request_ if input validation fails

- _Returns 404 Not Found_ if the user does not exist

- _Returns 500_ on Internal server or database error

## Get Post By ID

The endpoint `GET /posts/:id` allows unauthenticated users to retrieve detailed information about a specific post by its unique ID.

## Authentication

This endpoint is public and does not require authentication

### Validation

Required fields:

- postId: is required and must be a valid MongoDB ObjectId (24-character hexadecimal string)

- Request headers should optionally include:

  `'Content-Type': 'application/json'`

### Example

```js
GET /posts/6843e455405ac6bd0430cff9
Headers:
{
  "Content-Type": "application/json"
}
```

## Flow

- _Route Layer_:

Receives the `HTTP request` and applies Joi middleware validation to ensure the `id parameter` is a valid 24-character hexadecimal string

- _Controller Layer_:

Extracts the id parameter from the URL

Calls the service to retrieve the post, handling HTTP responses and errors

- _Service Layer_:

Forwards the request to the repository with `id`

Receives the post from the repository and returns it to the controller

- _Repository Layer_:

Queries the database using the `id` parameter

Selects only the necessary fields (title, content, publishDate, authorId, tags, total_comments, total_likes)

Throws a `NotFoundException` if the post is not found

Returns the data as a JSON object to the service

- _Controller_:

Receives the final result from the service and sends a `200 OK HTTP response` with the post in JSON format

Handles errors by returning `404 Not Found` if the post does not exist or `500 Internal Server Error` for other failures

### Response Example

```js
Response: {
  '_id': '6843e455405ac6bd0430cff9',
  'title': 'Test Post 1749279829890',
  'content': '<p>This is a test post content.</p>',
  'publishDate': '2025-06-07T07:03:54.890Z',
  'authorId': '6843e455405ac6bd0430cff3',
  'tags': ['lifestyle'],
  'total_likes': 3,
  'total_comments': 2
}
```

## List Posts with Cursor-Based Pagination

This endpoint `GET/posts` retrieves a list of posts using cursor-based pagination. It supports unauthenticated requests.

## Authentication

This endpoint is public and does not require authentication.

## Validation

Query parameters:

- cursor: optional 24-character hexadecimal string, used for pagination

- limit: optional integer between 1 and 100, default is 10

- direction: optional string, either 'next' or 'prev', default is 'next'

Headers:

`'Content-Type': 'application/json' (optional)`

### Example

```js
GET /posts?cursor=664c1c4ae70aa5d6e7eaa000&limit=5&direction=next
Headers: {
  "Content-Type": "application/json"
}
```

## Flow

- _Route_:

Receives the HTTP request and applies Joi validation for cursor, limit, direction query parameters and content-type header

- _Controller_:

Extracts cursor, limit, and direction from the query
Calls `postService.getPostsByCursor`
Normalizes the data using `ListPostsCursorNormalizer`
Returns `HTTP 200` with normalized data or `500` on error.

- _Service Layer_:

Forwards the request to the repository
Returns the list of posts

_Repository_:

Builds MongoDB query filtering \_id based on cursor and direction
Applies sorting and limit
Throws internal exceptions on errors
Returns the array of posts

## Response Example

```js
{
  "posts": [
    {
      "id": "6843ff6d4d8a3d68158edea5",
      "title": "Test Post",
      "content": "<p>This is a test post content.</p>",
      "authorId": "6843ff6d4d8a3d68158ede9b",
      "tags": [
        "news",
        "tech"
      ],
      "publishDate": "2025-06-07T08:59:30.909Z",
      "total_comments": 0,
      "total_likes": 0
    },
  ],
  "cursor": "664c1c4ae70aa5d6e7eaa000",
  "limit": 5,
  "direction": "next",
  "nextCursor": "6843ff6d4d8a3d68158edea7",
  "prevCursor": "6843ff6d4d8a3d68158edea5"
}
```

## Get Comment By Id

This endpoint `GET /comments/:id` retrieves a single comment by its unique identifier.

## Authentication

This endpoint is public and does not require authentication

## Validation

Route Parameters:

- id: required, 24-character hexadecimal string (MongoDB ObjectId)

- Headers:

`'Content-Type': 'application/json' (optional)`

## Flow

- _Route_:

The request is validated using Joi. This validation ensures that the `:id parameter` is a valid 24-character hexadecimal string, which matches the format of a MongoDB ObjectId.

- _Controller_:

Once validation passes, control is handed off to the controller. The controller extracts the comment ID from the URL parameters and calls the `getCommentById method` from the service layer. It handles different types of responses based on what the service returns:

- If the comment is found, it responds with a `200 OK` and the comment data in JSON format

- If no comment matches the provided ID, it returns a `404 Not Found error` with a clear message

- In case of unexpected errors, it returns a `500 Internal Server Error`

- _Service_:

The service layer is responsible for coordinating the business logic. It simply forwards the ID to the repository layer by calling `commentRepository.findById`, then returns whatever the repository provides.

- _Repository_:

The repository interacts directly with the database. It uses `commentSchema.findById` to search for the comment by its MongoDB ID.

- If the comment is found, it returns the result

- If no match is found, it throws a NotFoundException

- If something goes wrong during the database operation, it throws a MongoInternalException

### Response Example

```js
{
  _id: "6843ff6d4d8a3d68158edea5",
  postId: "6843ff6d4d8a3d68158ede9c",
  authorId: "6843ff6d4d8a3d68158ede9b",
  text: "This is a test comment",
  created_at: "2025-06-07T08:59:30.909Z",
}
```

or

```js
{
  code: "COMMENT_NOT_FOUND",
  message: "Comment not found"
}
```

## Get Comments By Post

This endpoint `GET /posts/:id/comments` retrieves a list of comments associated with a specific post, supporting cursor-based pagination.

## Authentication

This endpoint is public and does not require authentication.

## Validation

Route Parameters:

- id: required, 24-character hexadecimal string (MongoDB ObjectId)

Query Parameters (optional):

- cursor: optional 24-character hex string or null/empty, used for pagination

- direction: 'next' or 'prev' (default: 'next'), indicates pagination direction

- limit: integer between 1 and 100 (default: 10), limits the number of comments returned

Headers (optional):

- Content-Type: 'application/json'

## Flow

- \*Route\*:

When a client sends a request to `GET /posts/:id/comments`, the server first validates the input parameters. The post ID in the URL must be a valid 24-character hexadecimal string, matching the MongoDB ObjectId. Additionally, optional query parameters for pagination —such as cursor, direction, and limit— are also validated.

- _Controller_:

The controller extracts the post ID and pagination parameters from the request. It then calls the service layer’s method to fetch the comments for the specified post, providing the pagination options as needed. Before sending the response, the controller normalizes the comments data and returns it with a 200 OK status in JSON format.

- \*Service Layer\*:

Inside the service layer, the first step is to confirm that the post actually exists in the database. If the post is not found, the service throws a NotFoundException.

If the post exists, the service requests the repository to retrieve the comments related to that post.

- \*Repository Layer\*:

The repository performs a database query that:

- Filters comments by the given post ID

- Applies cursor-based pagination by filtering comments either after or before the provided cursor ID, depending on the pagination direction (next or prev)

- Sorts the comments in ascending or descending order accordingly

- Limits the number of returned comments to the requested limit

If the database operation is successful, the repository returns the list of comments to the service, which then passes them back to the controller.

### Response Example

```js
Response body: {
  comments: [
    {
      id: '684dacf4690e23fe025bb9fc',
      text: 'This is a test comment 2',
      authorId: '684dacf4690e23fe025bb9ed',
      postId: '684dacf4690e23fe025bb9f5',
      created_at: '2025-06-14T17:10:12.929Z'
    },
    {
      id: '684dacf4690e23fe025bba00',
      text: 'This is a test comment 3',
      authorId: '684dacf4690e23fe025bb9ed',
      postId: '684dacf4690e23fe025bb9f5',
      created_at: '2025-06-14T17:10:12.937Z'
    }
  ],
  cursor: '684dacf4690e23fe025bb9f8',
  limit: 2,
  direction: 'next',
  nextCursor: '684dacf4690e23fe025bba00',
  prevCursor: '684dacf4690e23fe025bb9fc'
}
```

## Testing

This project includes a full test suite for all endpoints.

To run tests:

```bash
npm test
```

For details on the test suite, see [Testing Documentation](./docs/testing.md).